/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Teampage
 * Uoslife Teampage API Swagger
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';

import type {
  ArticleDetailResponse,
  CommentCreateRequest,
  CommentResponse,
  CommentUpdateRequest,
  CreateArticleRequest,
  ErrorResponse,
  FindArticleParams,
  GetAllLogParams,
  ImageUploadResponse,
  MyInfoResponse,
  NotificationAcceptedResponse,
  NotificationLogResponse,
  NotificationRequest,
  PageArticleListItem,
  ReactionRequest,
  ReactionResponse,
  SearchArticlesParams,
  UpdateArticleRequest,
  UploadImageBody,
  UploadImageParams,
  UploadThumbnailImageBody,
  UploadThumbnailImageParams,
} from './teampage.schemas';

import { apiInstance } from '../../api-instance';
import type { ErrorType, BodyType } from '../../api-instance';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const sendNotification = (
  notificationRequest: BodyType<NotificationRequest>,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<NotificationAcceptedResponse>(
    {
      url: `/notifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: notificationRequest,
      signal,
    },
    options,
  );
};

export const getSendNotificationMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendNotification>>,
    TError,
    { data: BodyType<NotificationRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendNotification>>,
  TError,
  { data: BodyType<NotificationRequest> },
  TContext
> => {
  const mutationKey = ['sendNotification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendNotification>>,
    { data: BodyType<NotificationRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return sendNotification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof sendNotification>>>;
export type SendNotificationMutationBody = BodyType<NotificationRequest>;
export type SendNotificationMutationError = ErrorType<unknown>;

export const useSendNotification = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendNotification>>,
      TError,
      { data: BodyType<NotificationRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendNotification>>,
  TError,
  { data: BodyType<NotificationRequest> },
  TContext
> => {
  const mutationOptions = getSendNotificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const searchArticles = (
  params: SearchArticlesParams,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<PageArticleListItem>({ url: `/articles`, method: 'GET', params, signal }, options);
};

export const getSearchArticlesQueryKey = (params?: SearchArticlesParams) => {
  return [`/articles`, ...(params ? [params] : [])] as const;
};

export const getSearchArticlesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchArticles>>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchArticles>>> = ({ signal }) =>
    searchArticles(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchArticlesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchArticles>>>;
export type SearchArticlesInfiniteQueryError = ErrorType<unknown>;

export function useSearchArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchArticles>>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchArticles>>,
          TError,
          Awaited<ReturnType<typeof searchArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchArticles>>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchArticles>>,
          TError,
          Awaited<ReturnType<typeof searchArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchArticles>>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useSearchArticlesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchArticles>>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchArticlesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchSearchArticlesInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getSearchArticlesInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getSearchArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchArticles>>> = ({ signal }) =>
    searchArticles(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof searchArticles>>>;
export type SearchArticlesQueryError = ErrorType<unknown>;

export function useSearchArticles<TData = Awaited<ReturnType<typeof searchArticles>>, TError = ErrorType<unknown>>(
  params: SearchArticlesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchArticles>>,
          TError,
          Awaited<ReturnType<typeof searchArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticles<TData = Awaited<ReturnType<typeof searchArticles>>, TError = ErrorType<unknown>>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchArticles>>,
          TError,
          Awaited<ReturnType<typeof searchArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticles<TData = Awaited<ReturnType<typeof searchArticles>>, TError = ErrorType<unknown>>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useSearchArticles<TData = Awaited<ReturnType<typeof searchArticles>>, TError = ErrorType<unknown>>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchArticlesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchSearchArticlesQuery = async <
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getSearchArticlesQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getSearchArticlesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchArticles>>> = ({ signal }) =>
    searchArticles(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof searchArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchArticlesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof searchArticles>>>;
export type SearchArticlesSuspenseQueryError = ErrorType<unknown>;

export function useSearchArticlesSuspense<
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticlesSuspense<
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchArticlesSuspense<
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useSearchArticlesSuspense<
  TData = Awaited<ReturnType<typeof searchArticles>>,
  TError = ErrorType<unknown>,
>(
  params: SearchArticlesParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof searchArticles>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchArticlesSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createArticle = (
  createArticleRequest: BodyType<CreateArticleRequest>,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<ArticleDetailResponse>(
    {
      url: `/articles`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createArticleRequest,
      signal,
    },
    options,
  );
};

export const getCreateArticleMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticle>>,
    TError,
    { data: BodyType<CreateArticleRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: BodyType<CreateArticleRequest> },
  TContext
> => {
  const mutationKey = ['createArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticle>>,
    { data: BodyType<CreateArticleRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createArticle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof createArticle>>>;
export type CreateArticleMutationBody = BodyType<CreateArticleRequest>;
export type CreateArticleMutationError = ErrorType<unknown>;

export const useCreateArticle = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createArticle>>,
      TError,
      { data: BodyType<CreateArticleRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: BodyType<CreateArticleRequest> },
  TContext
> => {
  const mutationOptions = getCreateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const truncateWithKids = (options?: SecondParameter<typeof apiInstance>) => {
  return apiInstance<null>({ url: `/articles`, method: 'DELETE' }, options);
};

export const getTruncateWithKidsMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof truncateWithKids>>, TError, void, TContext>;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof truncateWithKids>>, TError, void, TContext> => {
  const mutationKey = ['truncateWithKids'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof truncateWithKids>>, void> = () => {
    return truncateWithKids(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TruncateWithKidsMutationResult = NonNullable<Awaited<ReturnType<typeof truncateWithKids>>>;

export type TruncateWithKidsMutationError = ErrorType<unknown>;

export const useTruncateWithKids = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof truncateWithKids>>, TError, void, TContext>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof truncateWithKids>>, TError, void, TContext> => {
  const mutationOptions = getTruncateWithKidsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const addReaction = (
  articleId: number,
  reactionRequest: BodyType<ReactionRequest>,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<ReactionResponse>(
    {
      url: `/articles/${encodeURIComponent(String(articleId))}/likes`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reactionRequest,
      signal,
    },
    options,
  );
};

export const getAddReactionMutationOptions = <
  TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReaction>>,
    TError,
    { articleId: number; data: BodyType<ReactionRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addReaction>>,
  TError,
  { articleId: number; data: BodyType<ReactionRequest> },
  TContext
> => {
  const mutationKey = ['addReaction'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReaction>>,
    { articleId: number; data: BodyType<ReactionRequest> }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return addReaction(articleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddReactionMutationResult = NonNullable<Awaited<ReturnType<typeof addReaction>>>;
export type AddReactionMutationBody = BodyType<ReactionRequest>;
export type AddReactionMutationError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>;

export const useAddReaction = <
  TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addReaction>>,
      TError,
      { articleId: number; data: BodyType<ReactionRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addReaction>>,
  TError,
  { articleId: number; data: BodyType<ReactionRequest> },
  TContext
> => {
  const mutationOptions = getAddReactionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const findComment = (articleId: number, options?: SecondParameter<typeof apiInstance>, signal?: AbortSignal) => {
  return apiInstance<CommentResponse[]>(
    { url: `/articles/${encodeURIComponent(String(articleId))}/comments`, method: 'GET', signal },
    options,
  );
};

export const getFindCommentQueryKey = (articleId?: number) => {
  return [`/articles/${articleId}/comments`] as const;
};

export const getFindCommentInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findComment>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindCommentQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findComment>>> = ({ signal }) =>
    findComment(articleId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findComment>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindCommentInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findComment>>>;
export type FindCommentInfiniteQueryError = ErrorType<unknown>;

export function useFindCommentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findComment>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComment>>,
          TError,
          Awaited<ReturnType<typeof findComment>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindCommentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findComment>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComment>>,
          TError,
          Awaited<ReturnType<typeof findComment>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindCommentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findComment>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindCommentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findComment>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindCommentInfiniteQueryOptions(articleId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchFindCommentInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof findComment>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  articleId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getFindCommentInfiniteQueryOptions(articleId, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getFindCommentQueryOptions = <
  TData = Awaited<ReturnType<typeof findComment>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindCommentQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findComment>>> = ({ signal }) =>
    findComment(articleId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findComment>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindCommentQueryResult = NonNullable<Awaited<ReturnType<typeof findComment>>>;
export type FindCommentQueryError = ErrorType<unknown>;

export function useFindComment<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComment>>,
          TError,
          Awaited<ReturnType<typeof findComment>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindComment<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findComment>>,
          TError,
          Awaited<ReturnType<typeof findComment>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindComment<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindComment<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindCommentQueryOptions(articleId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchFindCommentQuery = async <
  TData = Awaited<ReturnType<typeof findComment>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getFindCommentQueryOptions(articleId, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getFindCommentSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof findComment>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindCommentQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findComment>>> = ({ signal }) =>
    findComment(articleId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof findComment>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindCommentSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findComment>>>;
export type FindCommentSuspenseQueryError = ErrorType<unknown>;

export function useFindCommentSuspense<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindCommentSuspense<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindCommentSuspense<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindCommentSuspense<TData = Awaited<ReturnType<typeof findComment>>, TError = ErrorType<unknown>>(
  articleId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findComment>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindCommentSuspenseQueryOptions(articleId, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createComment = (
  articleId: number,
  commentCreateRequest: BodyType<CommentCreateRequest>,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<CommentResponse>(
    {
      url: `/articles/${encodeURIComponent(String(articleId))}/comments`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: commentCreateRequest,
      signal,
    },
    options,
  );
};

export const getCreateCommentMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createComment>>,
    TError,
    { articleId: number; data: BodyType<CommentCreateRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createComment>>,
  TError,
  { articleId: number; data: BodyType<CommentCreateRequest> },
  TContext
> => {
  const mutationKey = ['createComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createComment>>,
    { articleId: number; data: BodyType<CommentCreateRequest> }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return createComment(articleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>;
export type CreateCommentMutationBody = BodyType<CommentCreateRequest>;
export type CreateCommentMutationError = ErrorType<unknown>;

export const useCreateComment = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createComment>>,
      TError,
      { articleId: number; data: BodyType<CommentCreateRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createComment>>,
  TError,
  { articleId: number; data: BodyType<CommentCreateRequest> },
  TContext
> => {
  const mutationOptions = getCreateCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const uploadThumbnailImage = (
  uploadThumbnailImageBody: BodyType<UploadThumbnailImageBody>,
  params: UploadThumbnailImageParams,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<ImageUploadResponse>(
    {
      url: `/articles/uploadThumbnailImage`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: uploadThumbnailImageBody,
      params,
      signal,
    },
    options,
  );
};

export const getUploadThumbnailImageMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadThumbnailImage>>,
    TError,
    { data: BodyType<UploadThumbnailImageBody>; params: UploadThumbnailImageParams },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadThumbnailImage>>,
  TError,
  { data: BodyType<UploadThumbnailImageBody>; params: UploadThumbnailImageParams },
  TContext
> => {
  const mutationKey = ['uploadThumbnailImage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadThumbnailImage>>,
    { data: BodyType<UploadThumbnailImageBody>; params: UploadThumbnailImageParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return uploadThumbnailImage(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadThumbnailImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadThumbnailImage>>>;
export type UploadThumbnailImageMutationBody = BodyType<UploadThumbnailImageBody>;
export type UploadThumbnailImageMutationError = ErrorType<unknown>;

export const useUploadThumbnailImage = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadThumbnailImage>>,
      TError,
      { data: BodyType<UploadThumbnailImageBody>; params: UploadThumbnailImageParams },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadThumbnailImage>>,
  TError,
  { data: BodyType<UploadThumbnailImageBody>; params: UploadThumbnailImageParams },
  TContext
> => {
  const mutationOptions = getUploadThumbnailImageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const uploadImage = (
  uploadImageBody: BodyType<UploadImageBody>,
  params: UploadImageParams,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<ImageUploadResponse>(
    {
      url: `/articles/uploadImage`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: uploadImageBody,
      params,
      signal,
    },
    options,
  );
};

export const getUploadImageMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadImage>>,
    TError,
    { data: BodyType<UploadImageBody>; params: UploadImageParams },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadImage>>,
  TError,
  { data: BodyType<UploadImageBody>; params: UploadImageParams },
  TContext
> => {
  const mutationKey = ['uploadImage'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadImage>>,
    { data: BodyType<UploadImageBody>; params: UploadImageParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return uploadImage(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadImage>>>;
export type UploadImageMutationBody = BodyType<UploadImageBody>;
export type UploadImageMutationError = ErrorType<unknown>;

export const useUploadImage = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadImage>>,
      TError,
      { data: BodyType<UploadImageBody>; params: UploadImageParams },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadImage>>,
  TError,
  { data: BodyType<UploadImageBody>; params: UploadImageParams },
  TContext
> => {
  const mutationOptions = getUploadImageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const findArticle = (
  articleId: number,
  params?: FindArticleParams,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<ArticleDetailResponse>(
    { url: `/articles/${encodeURIComponent(String(articleId))}`, method: 'GET', params, signal },
    options,
  );
};

export const getFindArticleQueryKey = (articleId?: number, params?: FindArticleParams) => {
  return [`/articles/${articleId}`, ...(params ? [params] : [])] as const;
};

export const getFindArticleInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findArticle>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindArticleQueryKey(articleId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticle>>> = ({ signal }) =>
    findArticle(articleId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindArticleInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findArticle>>>;
export type FindArticleInfiniteQueryError = ErrorType<unknown>;

export function useFindArticleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticle>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params: undefined | FindArticleParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticle>>,
          TError,
          Awaited<ReturnType<typeof findArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticle>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticle>>,
          TError,
          Awaited<ReturnType<typeof findArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticle>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindArticleInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findArticle>>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindArticleInfiniteQueryOptions(articleId, params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchFindArticleInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof findArticle>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getFindArticleInfiniteQueryOptions(articleId, params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getFindArticleQueryOptions = <
  TData = Awaited<ReturnType<typeof findArticle>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindArticleQueryKey(articleId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticle>>> = ({ signal }) =>
    findArticle(articleId, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindArticleQueryResult = NonNullable<Awaited<ReturnType<typeof findArticle>>>;
export type FindArticleQueryError = ErrorType<unknown>;

export function useFindArticle<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params: undefined | FindArticleParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticle>>,
          TError,
          Awaited<ReturnType<typeof findArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticle<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArticle>>,
          TError,
          Awaited<ReturnType<typeof findArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticle<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindArticle<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindArticleQueryOptions(articleId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchFindArticleQuery = async <
  TData = Awaited<ReturnType<typeof findArticle>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getFindArticleQueryOptions(articleId, params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getFindArticleSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof findArticle>>,
  TError = ErrorType<unknown>,
>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindArticleQueryKey(articleId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findArticle>>> = ({ signal }) =>
    findArticle(articleId, params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof findArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindArticleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findArticle>>>;
export type FindArticleSuspenseQueryError = ErrorType<unknown>;

export function useFindArticleSuspense<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params: undefined | FindArticleParams,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticleSuspense<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindArticleSuspense<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFindArticleSuspense<TData = Awaited<ReturnType<typeof findArticle>>, TError = ErrorType<unknown>>(
  articleId: number,
  params?: FindArticleParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findArticle>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindArticleSuspenseQueryOptions(articleId, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteArticle = (articleId: number, options?: SecondParameter<typeof apiInstance>) => {
  return apiInstance<null>({ url: `/articles/${encodeURIComponent(String(articleId))}`, method: 'DELETE' }, options);
};

export const getDeleteArticleMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError, { articleId: number }, TContext>;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError, { articleId: number }, TContext> => {
  const mutationKey = ['deleteArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteArticle>>, { articleId: number }> = (props) => {
    const { articleId } = props ?? {};

    return deleteArticle(articleId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteArticleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArticle>>>;

export type DeleteArticleMutationError = ErrorType<unknown>;

export const useDeleteArticle = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteArticle>>, TError, { articleId: number }, TContext>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteArticle>>, TError, { articleId: number }, TContext> => {
  const mutationOptions = getDeleteArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateArticle = (
  articleId: number,
  updateArticleRequest: BodyType<UpdateArticleRequest>,
  options?: SecondParameter<typeof apiInstance>,
) => {
  return apiInstance<ArticleDetailResponse>(
    {
      url: `/articles/${encodeURIComponent(String(articleId))}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateArticleRequest,
    },
    options,
  );
};

export const getUpdateArticleMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArticle>>,
    TError,
    { articleId: number; data: BodyType<UpdateArticleRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: BodyType<UpdateArticleRequest> },
  TContext
> => {
  const mutationKey = ['updateArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateArticle>>,
    { articleId: number; data: BodyType<UpdateArticleRequest> }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return updateArticle(articleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof updateArticle>>>;
export type UpdateArticleMutationBody = BodyType<UpdateArticleRequest>;
export type UpdateArticleMutationError = ErrorType<unknown>;

export const useUpdateArticle = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateArticle>>,
      TError,
      { articleId: number; data: BodyType<UpdateArticleRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: BodyType<UpdateArticleRequest> },
  TContext
> => {
  const mutationOptions = getUpdateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteComment = (articleId: number, commentId: number, options?: SecondParameter<typeof apiInstance>) => {
  return apiInstance<null>(
    {
      url: `/articles/${encodeURIComponent(String(articleId))}/comments/${encodeURIComponent(String(commentId))}`,
      method: 'DELETE',
    },
    options,
  );
};

export const getDeleteCommentMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteComment>>,
    TError,
    { articleId: number; commentId: number },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { articleId: number; commentId: number },
  TContext
> => {
  const mutationKey = ['deleteComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteComment>>,
    { articleId: number; commentId: number }
  > = (props) => {
    const { articleId, commentId } = props ?? {};

    return deleteComment(articleId, commentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>;

export type DeleteCommentMutationError = ErrorType<unknown>;

export const useDeleteComment = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteComment>>,
      TError,
      { articleId: number; commentId: number },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { articleId: number; commentId: number },
  TContext
> => {
  const mutationOptions = getDeleteCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateComment = (
  articleId: number,
  commentId: number,
  commentUpdateRequest: BodyType<CommentUpdateRequest>,
  options?: SecondParameter<typeof apiInstance>,
) => {
  return apiInstance<CommentResponse>(
    {
      url: `/articles/${encodeURIComponent(String(articleId))}/comments/${encodeURIComponent(String(commentId))}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: commentUpdateRequest,
    },
    options,
  );
};

export const getUpdateCommentMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComment>>,
    TError,
    { articleId: number; commentId: number; data: BodyType<CommentUpdateRequest> },
    TContext
  >;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { articleId: number; commentId: number; data: BodyType<CommentUpdateRequest> },
  TContext
> => {
  const mutationKey = ['updateComment'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateComment>>,
    { articleId: number; commentId: number; data: BodyType<CommentUpdateRequest> }
  > = (props) => {
    const { articleId, commentId, data } = props ?? {};

    return updateComment(articleId, commentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateComment>>>;
export type UpdateCommentMutationBody = BodyType<CommentUpdateRequest>;
export type UpdateCommentMutationError = ErrorType<unknown>;

export const useUpdateComment = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateComment>>,
      TError,
      { articleId: number; commentId: number; data: BodyType<CommentUpdateRequest> },
      TContext
    >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { articleId: number; commentId: number; data: BodyType<CommentUpdateRequest> },
  TContext
> => {
  const mutationOptions = getUpdateCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAllLog = (
  params: GetAllLogParams,
  options?: SecondParameter<typeof apiInstance>,
  signal?: AbortSignal,
) => {
  return apiInstance<NotificationLogResponse[]>({ url: `/notifications/logs`, method: 'GET', params, signal }, options);
};

export const getGetAllLogQueryKey = (params?: GetAllLogParams) => {
  return [`/notifications/logs`, ...(params ? [params] : [])] as const;
};

export const getGetAllLogInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAllLog>>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllLogQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllLog>>> = ({ signal }) =>
    getAllLog(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllLog>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllLogInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllLog>>>;
export type GetAllLogInfiniteQueryError = ErrorType<unknown>;

export function useGetAllLogInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllLog>>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllLog>>, TError, Awaited<ReturnType<typeof getAllLog>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLogInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllLog>>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllLog>>,
          TError,
          Awaited<ReturnType<typeof getAllLog>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLogInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllLog>>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetAllLogInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAllLog>>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllLogInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetAllLogInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getAllLog>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAllLogInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getGetAllLogQueryOptions = <TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllLogQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllLog>>> = ({ signal }) =>
    getAllLog(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllLog>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllLogQueryResult = NonNullable<Awaited<ReturnType<typeof getAllLog>>>;
export type GetAllLogQueryError = ErrorType<unknown>;

export function useGetAllLog<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getAllLog>>, TError, Awaited<ReturnType<typeof getAllLog>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLog<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllLog>>,
          TError,
          Awaited<ReturnType<typeof getAllLog>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLog<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetAllLog<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllLogQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetAllLogQuery = async <
  TData = Awaited<ReturnType<typeof getAllLog>>,
  TError = ErrorType<unknown>,
>(
  queryClient: QueryClient,
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetAllLogQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetAllLogSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllLog>>,
  TError = ErrorType<unknown>,
>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllLogQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllLog>>> = ({ signal }) =>
    getAllLog(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllLog>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllLogSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAllLog>>>;
export type GetAllLogSuspenseQueryError = ErrorType<unknown>;

export function useGetAllLogSuspense<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLogSuspense<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllLogSuspense<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetAllLogSuspense<TData = Awaited<ReturnType<typeof getAllLog>>, TError = ErrorType<unknown>>(
  params: GetAllLogParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllLog>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllLogSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const me = (options?: SecondParameter<typeof apiInstance>, signal?: AbortSignal) => {
  return apiInstance<MyInfoResponse>({ url: `/auth/me`, method: 'GET', signal }, options);
};

export const getMeQueryKey = () => {
  return [`/auth/me`] as const;
};

export const getMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof me>>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
  request?: SecondParameter<typeof apiInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeInfiniteQueryError = ErrorType<unknown>;

export function useMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof me>>>, TError = ErrorType<unknown>>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, Awaited<ReturnType<typeof me>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof me>>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, Awaited<ReturnType<typeof me>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof me>>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof me>>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchMeInfiniteQuery = async <TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getMeInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getMeQueryOptions = <TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
  request?: SecondParameter<typeof apiInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeQueryError = ErrorType<unknown>;

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, Awaited<ReturnType<typeof me>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof me>>, TError, Awaited<ReturnType<typeof me>>>,
        'initialData'
      >;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchMeQuery = async <TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
): Promise<QueryClient> => {
  const queryOptions = getMeQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getMeSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof me>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
  request?: SecondParameter<typeof apiInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) => me(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeSuspenseQueryError = ErrorType<unknown>;

export function useMeSuspense<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMeSuspense<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMeSuspense<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMeSuspense<TData = Awaited<ReturnType<typeof me>>, TError = ErrorType<unknown>>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMeSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const truncate = (options?: SecondParameter<typeof apiInstance>) => {
  return apiInstance<null>({ url: `/articles/comments`, method: 'DELETE' }, options);
};

export const getTruncateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof truncate>>, TError, void, TContext>;
  request?: SecondParameter<typeof apiInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof truncate>>, TError, void, TContext> => {
  const mutationKey = ['truncate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof truncate>>, void> = () => {
    return truncate(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TruncateMutationResult = NonNullable<Awaited<ReturnType<typeof truncate>>>;

export type TruncateMutationError = ErrorType<unknown>;

export const useTruncate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof truncate>>, TError, void, TContext>;
    request?: SecondParameter<typeof apiInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof truncate>>, TError, void, TContext> => {
  const mutationOptions = getTruncateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
