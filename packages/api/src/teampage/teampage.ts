/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * Teampage
 * Uoslife Teampage API Swagger
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';

import type {
  ArticleDetailResponse,
  CreateArticleRequest,
  Me200,
  UpdateArticleRequest,
} from './teampage.schemas';

export type createArticleResponse200 = {
  data: ArticleDetailResponse;
  status: 200;
};

export type createArticleResponseComposite = createArticleResponse200;

export type createArticleResponse = createArticleResponseComposite & {
  headers: Headers;
};

export const getCreateArticleUrl = () => {
  return `https://apis.uoslife.team/articles`;
};

export const createArticle = async (
  createArticleRequest: CreateArticleRequest,
  options?: RequestInit,
): Promise<createArticleResponse> => {
  const res = await fetch(getCreateArticleUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createArticleRequest),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: createArticleResponse['data'] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as createArticleResponse;
};

export const getCreateArticleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticle>>,
    TError,
    { data: CreateArticleRequest },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: CreateArticleRequest },
  TContext
> => {
  const mutationKey = ['createArticle'];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticle>>,
    { data: CreateArticleRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createArticle(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArticle>>
>;
export type CreateArticleMutationBody = CreateArticleRequest;
export type CreateArticleMutationError = unknown;

export const useCreateArticle = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createArticle>>,
      TError,
      { data: CreateArticleRequest },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: CreateArticleRequest },
  TContext
> => {
  const mutationOptions = getCreateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type updateArticleResponse200 = {
  data: ArticleDetailResponse;
  status: 200;
};

export type updateArticleResponseComposite = updateArticleResponse200;

export type updateArticleResponse = updateArticleResponseComposite & {
  headers: Headers;
};

export const getUpdateArticleUrl = (articleId: number) => {
  return `https://apis.uoslife.team/articles/${articleId}`;
};

export const updateArticle = async (
  articleId: number,
  updateArticleRequest: UpdateArticleRequest,
  options?: RequestInit,
): Promise<updateArticleResponse> => {
  const res = await fetch(getUpdateArticleUrl(articleId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(updateArticleRequest),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: updateArticleResponse['data'] = body ? JSON.parse(body) : {};

  return {
    data,
    status: res.status,
    headers: res.headers,
  } as updateArticleResponse;
};

export const getUpdateArticleMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArticle>>,
    TError,
    { articleId: number; data: UpdateArticleRequest },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: UpdateArticleRequest },
  TContext
> => {
  const mutationKey = ['updateArticle'];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateArticle>>,
    { articleId: number; data: UpdateArticleRequest }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return updateArticle(articleId, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateArticle>>
>;
export type UpdateArticleMutationBody = UpdateArticleRequest;
export type UpdateArticleMutationError = unknown;

export const useUpdateArticle = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateArticle>>,
      TError,
      { articleId: number; data: UpdateArticleRequest },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: UpdateArticleRequest },
  TContext
> => {
  const mutationOptions = getUpdateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type meResponse200 = {
  data: Me200;
  status: 200;
};

export type meResponseComposite = meResponse200;

export type meResponse = meResponseComposite & {
  headers: Headers;
};

export const getMeUrl = () => {
  return `https://apis.uoslife.team/auth/me`;
};

export const me = async (options?: RequestInit): Promise<meResponse> => {
  const res = await fetch(getMeUrl(), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: meResponse['data'] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as meResponse;
};

export const getMeQueryKey = () => {
  return [`https://apis.uoslife.team/auth/me`] as const;
};

export const getMeQueryOptions = <
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) =>
    me({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MeQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeQueryError = unknown;

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof me>>,
          TError,
          Awaited<ReturnType<typeof me>>
        >,
        'initialData'
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMe<TData = Awaited<ReturnType<typeof me>>, TError = unknown>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchMeQuery = async <
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getMeQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getMeSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof me>>> = ({ signal }) =>
    me({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof me>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof me>>>;
export type MeSuspenseQueryError = unknown;

export function useMeSuspense<
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMeSuspense<
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useMeSuspense<
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useMeSuspense<
  TData = Awaited<ReturnType<typeof me>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof me>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getMeSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
